#!/usr/bin/env python3
"""Utility for creating or updating the local Google ADK agent configuration."""

from __future__ import annotations

import argparse
import os
import textwrap
from pathlib import Path


AGENT_TEMPLATE = """\"\"\"
Google ADK agent for the architecture-pattern ChromaDB knowledge base.

This file is generated by `scripts/setup_adk_agent.py` and can be regenerated
with updated configuration if needed.
\"\"\"

from __future__ import annotations

import os
import sys
from functools import lru_cache
from pathlib import Path
from typing import Any, Dict, Optional

from google.adk import Agent
from google.adk.tools import FunctionTool

# Ensure the repository root and src directory are importable when ADK loads the agent package.
REPO_ROOT = Path(__file__).resolve().parents[3]
SRC_DIR = REPO_ROOT / "src"
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))
if str(SRC_DIR) not in sys.path:
    sys.path.insert(0, str(SRC_DIR))

# Import only the components we need to avoid circular imports
from document_store.storage.vector_store import VectorStore
from document_store.search.rag_query import RAGQueryInterface

DEFAULT_PERSIST_PATH = {persist_path!r}
DEFAULT_PERSIST_IS_ABSOLUTE = {persist_is_absolute}
DEFAULT_COLLECTION_NAME = {collection_name!r}

_default_persist_directory = (
    DEFAULT_PERSIST_PATH
    if DEFAULT_PERSIST_IS_ABSOLUTE
    else str(REPO_ROOT / DEFAULT_PERSIST_PATH)
)

PERSIST_DIRECTORY = os.getenv(
    "ADK_PERSIST_DIRECTORY",
    _default_persist_directory,
)
COLLECTION_NAME = os.getenv("ADK_COLLECTION_NAME", DEFAULT_COLLECTION_NAME)
EMBEDDING_MODEL = os.getenv("ADK_EMBEDDING_MODEL")
DEFAULT_MODEL = os.getenv("ADK_MODEL", {model!r})
AGENT_NAME = os.getenv("ADK_AGENT_NAME", {agent_name!r})

DEFAULT_INSTRUCTION = (
    {instruction!r}
)


@lru_cache(maxsize=1)
def _get_vector_store() -> VectorStore:
    \"\"\"Build a lightweight vector store for direct ChromaDB access.\"\"\"
    return VectorStore(
        persist_directory=PERSIST_DIRECTORY,
        collection_name=COLLECTION_NAME,
        embedding_model=EMBEDDING_MODEL,
    )


@lru_cache(maxsize=1)
def _get_rag_interface() -> RAGQueryInterface:
    \"\"\"Build RAG interface for querying patterns.\"\"\"
    return RAGQueryInterface(_get_vector_store())


def query_architecture_patterns(
    query: str,
    n_results: int = 5,
    pattern_type: Optional[str] = None,
    vendor: Optional[str] = None,
) -> Dict[str, Any]:
    \"\"\"
    Search the ChromaDB store for architecture content.

    Args:
        query: Natural-language question or keyword search.
        n_results: Maximum number of vector hits to return.
        pattern_type: Optional filter matching the pattern slug (e.g. basic-rag).
        vendor: Optional vendor filter (gemini, azure, aws, etc.).
    \"\"\"
    rag_interface = _get_rag_interface()
    return rag_interface.query_patterns(
        query=query,
        n_results=n_results,
        pattern_type=pattern_type,
        vendor=vendor,
    )


def get_store_info() -> Dict[str, Any]:
    \"\"\"Return collection metadata (document counts, persistence path, etc.).\"\"\"
    vector_store = _get_vector_store()
    return vector_store.get_collection_info()


root_agent = Agent(
    name=AGENT_NAME,
    model=DEFAULT_MODEL,
    instruction=os.getenv("ADK_INSTRUCTION", DEFAULT_INSTRUCTION),
    description=(
        "Answers architecture-pattern and healthcare summarization questions "
        "by retrieving content from the embedded ChromaDB vector store."
    ),
    tools=[
        FunctionTool(query_architecture_patterns),
        FunctionTool(get_store_info),
    ],
)

__all__ = ["root_agent"]
"""


def _load_instruction(path: Path | None) -> str:
    if not path:
        return (
            "You are the reference librarian for the AI Summarization "
            "Reference Architecture. Use the available tools to search the "
            "local ChromaDB store for patterns, specifications, and healthcare "
            "use-case guidance. Always cite the `id` field (or metadata source) "
            "from tool responses when answering. If a question cannot be "
            "answered from the knowledge base, say so explicitly."
        )
    return path.read_text().strip()


def _determine_persist_path(path_value: str) -> tuple[str, bool]:
    path = Path(path_value)
    if path.is_absolute():
        return path.as_posix(), True
    return path.as_posix(), False


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Create or update the local Google ADK agent that serves "
        "the ChromaDB knowledge base."
    )
    parser.add_argument(
        "--persist-directory",
        default="data/chroma_db",
        help="Relative or absolute path to the ChromaDB persistence directory.",
    )
    parser.add_argument(
        "--collection-name",
        default="architecture_patterns",
        help="Name of the ChromaDB collection.",
    )
    parser.add_argument(
        "--model",
        default="gemini-2.5-flash",
        help="Default Gemini model used by the agent.",
    )
    parser.add_argument(
        "--agent-name",
        default="chromadb_pattern_agent",
        help="Name registered with the ADK agent.",
    )
    parser.add_argument(
        "--instruction-file",
        type=Path,
        help="Optional path to a text/Markdown file that contains the agent "
        "instruction block.",
    )
    parser.add_argument(
        "--overwrite",
        action="store_true",
        help="Overwrite the existing agent.py file if it already exists.",
    )

    args = parser.parse_args()

    repo_root = Path(__file__).resolve().parents[1]
    agent_dir = repo_root / ".adk" / "agents" / "chromadb_agent"
    agent_dir.mkdir(parents=True, exist_ok=True)

    init_path = agent_dir / "__init__.py"
    if not init_path.exists():
        init_path.write_text('"""ADK agent package for the ChromaDB-backed knowledge base."""\n\nfrom . import agent\n\n__all__ = ["agent"]\n')

    target_path = agent_dir / "agent.py"
    if target_path.exists() and not args.overwrite:
        print(
            f"[setup_adk_agent] {target_path} already exists. Use --overwrite to regenerate it."
        )
        return

    instruction = _load_instruction(args.instruction_file)
    persist_path, is_absolute = _determine_persist_path(args.persist_directory)

    content = AGENT_TEMPLATE.format(
        persist_path=persist_path,
        persist_is_absolute=is_absolute,
        collection_name=args.collection_name,
        model=args.model,
        agent_name=args.agent_name,
        instruction=textwrap.dedent(instruction),
    )
    target_path.write_text(content)
    print(f"[setup_adk_agent] Updated {target_path.relative_to(repo_root)}")


if __name__ == "__main__":
    main()
